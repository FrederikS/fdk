{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/securing-kubernetes-apps-with-keycloak-and-gatekeeper/","result":{"data":{"post":{"__typename":"MdxPost","slug":"/securing-kubernetes-apps-with-keycloak-and-gatekeeper/","title":"Securing Kubernetes Apps with Keycloak and Gatekeeper","date":"08.05.2020","tags":[{"name":"k8s","slug":"k-8-s"},{"name":"keycloak","slug":"keycloak"},{"name":"oidc","slug":"oidc"},{"name":"minikube","slug":"minikube"}],"description":"Example of securing an application by using keycloak and the OIDC protocol along with gatekeeper. Everything running inside a Kubernetes cluster.","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Securing Kubernetes Apps with Keycloak and Gatekeeper\",\n  \"date\": \"2020-05-08T00:00:00.000Z\",\n  \"description\": \"Example of securing an application by using keycloak and the OIDC protocol along with gatekeeper. Everything running inside a Kubernetes cluster.\",\n  \"tags\": [\"k8s\", \"keycloak\", \"oidc\", \"minikube\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today there are many ways to secure applications. With the rise of Kubernetes you might search for a self hosted open source\\nsolution for Identity Management. One of the most popular and powerful candidates is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.keycloak.org\"\n  }), \"Keycloak\"), \".\\nLets explore how these both work together.\"), mdx(\"p\", null, \"For my sample scenario I am going to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://minikube.sigs.k8s.io/docs/\"\n  }), \"minikube\"), \" to setup a local Kubernetes cluster to work with.\\nMy goal is to protect an application running in this cluster without the need of adding any code to it.\\nAdditionally it should be a scaling solution that can be easily added to any other application running inside the cluster.\\nAs sample application to protect, I chose \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://httpbin.org\"\n  }), \"httpbin\"), \".\"), mdx(\"h3\", null, \"Setting up Keycloak with persistence\"), mdx(\"p\", null, \"At the very first I need a running keycloak instance to authenticate to.\\nEven though the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/keycloak/keycloak-operator\"\n  }), \"keycloak-operator\"), \" seems to be in a pretty early stage\\nand might not work perfectly yet, I decided to give it a try. Lets clone the git repo and checkout the latest release.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> git clone git@github.com:keycloak/keycloak-operator.git\\n> cd keycloak-operator/\\n> git checkout refs/tags/9.0.2\\n\")), mdx(\"p\", null, \"In order to use the custom keycloak resource definitions coming from the operator, they need to be applied to the cluster.\\nThere is a Makefile target that can be used for this. Along with CRDs it also deploys some roles, bindings, service accounts etc.\\nWhen these basic cluster preparations are done, the keycloak-operator can be deployed into the newly created keycloak namespace.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> make cluster/prepare\\ncustomresourcedefinition.apiextensions.k8s.io/keycloakbackups.keycloak.org created\\ncustomresourcedefinition.apiextensions.k8s.io/keycloakclients.keycloak.org created\\ncustomresourcedefinition.apiextensions.k8s.io/keycloakrealms.keycloak.org created\\ncustomresourcedefinition.apiextensions.k8s.io/keycloaks.keycloak.org created\\ncustomresourcedefinition.apiextensions.k8s.io/keycloakusers.keycloak.org created\\nnamespace/keycloak created\\nrole.rbac.authorization.k8s.io/keycloak-operator created\\nrolebinding.rbac.authorization.k8s.io/keycloak-operator created\\nserviceaccount/keycloak-operator created\\n\\n> kubectl config set-context --current --namespace=keycloak\\n> kubectl apply -f deploy/operator.yaml\\ndeployment.apps/keycloak-operator created\\n\\n> kubectl rollout status deployment keycloak-operator\\nWaiting for deployment \\\"keycloak-operator\\\" rollout to finish: 0 of 1 updated replicas are available...\\ndeployment \\\"keycloak-operator\\\" successfully rolled out\\n\")), mdx(\"p\", null, \"Since I do not want to lose my configured keycloak data every time I restart my minikube kubernetes\\ncluster, I want to setup keycloak with persistence. Before proceeding with the installation of keycloak\\nit is necessary to setup a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PersistentVolume\"), \", that can be used for the underlying postgres database.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-yaml\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> cat <<EOF | kubectl create -f -\\nkind: PersistentVolume\\napiVersion: v1\\nmetadata:\\n  name: keycloak-postgresql-volume\\n  labels:\\n    app: keycloak\\nspec:\\n  storageClassName: standard\\n  capacity:\\n    storage: 2Gi\\n  accessModes:\\n    - ReadWriteOnce\\n  hostPath:\\n    path: \\\"/data\\\"\\nEOF\\n\")), mdx(\"p\", null, \"Finally keycloak can be installed by using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keycloaks.keycloak.org\"), \" CRD. It is going to deploy a postgresql database\\nusing our persistence volume, that then can get picked up by keycloak.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-yaml\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> cat <<EOF | kubectl create -f -\\napiVersion: keycloak.org/v1alpha1\\nkind: Keycloak\\nmetadata:\\n  name: keycloak\\n  labels:\\n    app: keycloak\\nspec:\\n  instances: 1\\nEOF\\n\\n> kubectl rollout status deployment keycloak-postgresql\\nWaiting for deployment \\\"keycloak-postgresql\\\" rollout to finish: 0 of 1 updated replicas are available...\\ndeployment \\\"keycloak-postgresql\\\" successfully rolled out\\n\\n> kubectl rollout status statefulset keycloak\\nWaiting for 1 pods to be ready...\\nWaiting for partitioned roll out to finish: 0 out of 1 new pods have been updated...\\nWaiting for 1 pods to be ready...\\nWaiting for 1 pods to be ready...\\npartitioned roll out complete: 1 new pods have been updated...\\n\")), mdx(\"p\", null, \"Keycloak is running and ready to be used.\\nTo setup an easy accessible address for the keycloak instance the minikube ingress addon together with a hostname entry can be used.\\nWhile I am at adding hostnames, I already add another one that I need for resolving my sample httpbin application later on.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> minikube addons enable ingress\\n\\uD83C\\uDF1F  The 'ingress' addon is enabled\\n\\n> echo \\\"$(minikube ip) keycloak.local httpbin.local\\\" | sudo tee -a /etc/hosts\\n192.168.39.31 keycloak.local httpbin.local\\n\")), mdx(\"p\", null, \"Of course the corresponding Kubernetes ingress resource needs to be created as well. This resource could also be created by the\\nkeycloak operator by passing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"externalAccess.enabled: True\"), \" to the keycloak spec, but it did not work for me due to some missing annotation\\nfor telling nginx to use https for the upstream service. So I created an ingress resource by myself.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-yaml\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> cat <<EOF | kubectl apply -f -\\napiVersion: networking.k8s.io/v1beta1\\nkind: Ingress\\nmetadata:\\n  name: keycloak\\n  annotations:\\n    nginx.ingress.kubernetes.io/backend-protocol: \\\"HTTPS\\\"\\nspec:\\n  rules:\\n  - host: keycloak.local\\n    http:\\n      paths:\\n      - backend:\\n          serviceName: keycloak\\n          servicePort: 8443\\nEOF\\n\")), mdx(\"p\", null, \"If everything is set up correctly, the keycloak instance should be accessible now.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> curl -I http://keycloak.local/auth/\\nHTTP/1.1 200 OK\\nServer: openresty/1.15.8.2\\nDate: Thu, 14 May 2020 12:05:06 GMT\\nContent-Type: text/html;charset=utf-8\\nContent-Length: 4071\\nConnection: keep-alive\\nVary: Accept-Encoding\\nCache-Control: no-cache, must-revalidate, no-transform, no-store\\nX-XSS-Protection: 1; mode=block\\nX-Frame-Options: SAMEORIGIN\\nContent-Security-Policy: frame-src 'self'; frame-ancestors 'self'; object-src 'none';\\nX-Robots-Tag: none\\nStrict-Transport-Security: max-age=31536000; includeSubDomains\\nX-Content-Type-Options: nosniff\\n\")), mdx(\"h3\", null, \"Configuring Keycloak for the client application\"), mdx(\"p\", null, \"Now, after keycloak was successfully installed to the cluster, it is time to prepare the instance for\\nthe client application. The easiest way might be to use the adminstration console UI from keycloak.\\nIt can be accessed via browser at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://keycloak.local/auth/admin/\"), \". The necessary admin credentials\\nhave been initially created as kubernetes secrets by the keycloak operator while installing.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> kubectl get secret credential-keycloak -o jsonpath=\\\"{.data.ADMIN_USERNAME}\\\" | base64 --decode; echo\\nadmin\\n\\n> kubectl get secret credential-keycloak -o jsonpath=\\\"{.data.ADMIN_PASSWORD}\\\" | base64 --decode; echo\\nP1Ps9dAGRsyyYA==\\n\")), mdx(\"p\", null, \"Taking the credentials to login to the adminstration console UI, the client configuration can be started.\\nFollowing steps have to be done:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Create a new realm. To not run into trouble with login later on, since I have not set up proper certificates for tls, I am setting an insecure \\\"Frontend URL\\\" to\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"http://keycloak.local/auth\"), \" for this realm.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add a client with protocol \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"openid-connect\"), \" and access type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"confidential\"), \". Add \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"http://httpbin.local/oauth/callback\"), \" to valid Redirect URIs.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Goto to the \\\"Client Scopes\\\" menu and add a new client scope. Create new protocol with mapper type audience, select your client in \\\"Included Client Audience\\\"\\nand set \\\"Add to access token\\\" to \\\"On\\\".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In client settings go to client scopes and add your created client scope containing the audience mapper.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add a user and set a password in the \\\"Credentials\\\" tab.\")), mdx(\"p\", null, \"I called my realm \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test\"), \" and my client \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"httpbin\"), \". By setting the client access-type to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"confidential\"), \" a client-secret has\\nbeen generated by keycloak. It is needed for the upcoming gatekeeper configuration and can be found at the credentials tab of\\nthe client configuration.\"), mdx(\"h3\", null, \"Deploying Client Application along with Keycloak Gatekeeper\"), mdx(\"p\", null, \"By having a running keycloak instance configured with proper client settings and a test user, everything is in place\\nto protect the sample httbin application. As mentioned in the introduction I would like to secure the application\\nwithout adding code. Here comes \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/keycloak/keycloak-gatekeeper\"\n  }), \"Keycloak Gatekeeper\"), \" into play, which\\nis an OIDC proxy service, handling authentication for an upstream application. The idea of gatekeeper is to have it as close\\nas possible to the upstream application, thats why I am going to deploy it as sidecar to the httpbin application.\\nBut before proceeding with the deployment, the client-secret (from keycloak client configuration) needs to be accessible in the cluster.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-yaml\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> CLIENT_SECRET=`echo -n '1f134722-0c21-4490-8bf6-faec7f61490b' | base64`\\n\\n> cat <<EOF | kubectl create -f -\\napiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: httpbin-gatekeeper-secret\\ntype: Opaque\\ndata:\\n  client-secret: $CLIENT_SECRET\\nEOF\\n\")), mdx(\"p\", null, \"Having the secret in place, finally the sample application along with gatekeeper can be deployed.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-yaml\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> cat <<EOF | kubectl apply -f -\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: httpbin\\nspec:\\n  selector:\\n    matchLabels:\\n      app: httpbin\\n  template:\\n    metadata:\\n      labels:\\n        app: httpbin\\n    spec:\\n      containers:\\n      - name: httpbin\\n        image: docker.io/kennethreitz/httpbin\\n        imagePullPolicy: IfNotPresent\\n        ports:\\n          - containerPort: 80\\n      - name: gatekeeper-sidecar\\n        image: keycloak/keycloak-gatekeeper\\n        imagePullPolicy: IfNotPresent\\n        ports:\\n          - name: http-gatekeeper\\n            containerPort: 3000\\n        args:\\n          - --discovery-url=http://keycloak.local/auth/realms/test\\n          - --client-id=httpbin\\n          - --listen=0.0.0.0:3000\\n          - --upstream-url=http://127.0.0.1:80\\n          - --secure-cookie=false\\n          - --openid-provider-proxy=http://keycloak-discovery:8080\\n        env:\\n          - name: PROXY_CLIENT_SECRET\\n            valueFrom:\\n              secretKeyRef:\\n                name: httpbin-gatekeeper-secret\\n                key: client-secret\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: httpbin\\n  labels:\\n    app: httpbin\\nspec:\\n  ports:\\n  - name: http\\n    port: 80\\n    targetPort: http-gatekeeper\\n  selector:\\n    app: httpbin\\n  type: ClusterIP\\n---\\napiVersion: networking.k8s.io/v1beta1\\nkind: Ingress\\nmetadata:\\n  name: httpbin\\nspec:\\n  rules:\\n  - host: httpbin.local\\n    http:\\n      paths:\\n      - backend:\\n          serviceName: httpbin\\n          servicePort: 80\\nEOF\\n\\n> kubectl rollout status deployment httpbin\\nWaiting for deployment \\\"httpbin\\\" rollout to finish: 0 of 1 updated replicas are available...\\ndeployment \\\"httpbin\\\" successfully rolled out\\n\")), mdx(\"p\", null, \"To make the OIDC discovery of gatekeeper work with the internal Keycloak Kubernetes service URL, it is necessary to pass it as argument\\nto the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--openid-provider-proxy\"), \" parameter. I found a related issue \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/keycloak/keycloak-gatekeeper/issues/539\"\n  }), \"here\"), \".\"), mdx(\"h3\", null, \"Is my Application protected now?\"), mdx(\"p\", null, \"To verify the protection of my httpbin application, I am going to use a couple of curl commands.\\nFirst of all, what happens when I try to access my httpbin application?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> curl -I -L http://httpbin.local/\\n\\nHTTP/1.1 307 Temporary Redirect\\nServer: openresty/1.15.8.2\\nDate: Fri, 15 May 2020 11:51:38 GMT\\nContent-Type: text/html; charset=utf-8\\nConnection: keep-alive\\nLocation: /oauth/authorize?state=cadb8ba2-8487-4a86-9218-a4eb144cd6b8\\nSet-Cookie: request_uri=Lw==; Path=/; Domain=httpbin.local; HttpOnly\\nSet-Cookie: OAuth_Token_Request_State=cadb8ba2-8487-4a86-9218-a4eb144cd6b8; Path=/; Domain=httpbin.local; HttpOnly\\n\\nHTTP/1.1 307 Temporary Redirect\\nServer: openresty/1.15.8.2\\nDate: Fri, 15 May 2020 11:51:38 GMT\\nContent-Type: text/html; charset=utf-8\\nConnection: keep-alive\\nLocation: http://keycloak.local/auth/realms/test/protocol/openid-connect/auth?client_id=httpbin&redirect_uri=http%3A%2F%2Fhttpbin.local%2Foauth%2Fcallback&response_type=code&scope=openid+email+profile&state=cadb8ba2-8487-4a86-9218-a4eb144cd6b8\\n\\nHTTP/1.1 200 OK\\nServer: openresty/1.15.8.2\\nDate: Fri, 15 May 2020 11:51:38 GMT\\nContent-Type: text/html;charset=utf-8\\nContent-Length: 3041\\nConnection: keep-alive\\nVary: Accept-Encoding\\nCache-Control: no-store, must-revalidate, max-age=0\\nSet-Cookie: AUTH_SESSION_ID=570fa485-0497-4dc7-b903-cc1dc47d5857.keycloak-0; Version=1; Path=/auth/realms/test/; HttpOnly\\nSet-Cookie: KC_RESTART=eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIwMTQ2MTc4ZC05NGMzLTQ3ODUtYTQyNS02OThkMTA0YzdlNTEifQ.eyJjaWQiOiJodHRwYmluIiwicHR5Ijoib3BlbmlkLWNvbm5lY3QiLCJydXJpIjoiaHR0cDovL2h0dHBiaW4ubG9jYWwvb2F1dGgvY2FsbGJhY2siLCJhY3QiOiJBVVRIRU5USUNBVEUiLCJub3RlcyI6eyJzY29wZSI6Im9wZW5pZCBlbWFpbCBwcm9maWxlIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrLmxvY2FsL2F1dGgvcmVhbG1zL3Rlc3QiLCJyZXNwb25zZV90eXBlIjoiY29kZSIsInJlZGlyZWN0X3VyaSI6Imh0dHA6Ly9odHRwYmluLmxvY2FsL29hdXRoL2NhbGxiYWNrIiwic3RhdGUiOiJjYWRiOGJhMi04NDg3LTRhODYtOTIxOC1hNGViMTQ0Y2Q2YjgifX0.NVKObt_ujGgW3HyccqdYbG59ieutJDu-nW38eAXRdXs; Version=1; Path=/auth/realms/test/; HttpOnly\\nX-XSS-Protection: 1; mode=block\\nX-Frame-Options: SAMEORIGIN\\nContent-Security-Policy: frame-src 'self'; frame-ancestors 'self'; object-src 'none';\\nX-Robots-Tag: none\\nStrict-Transport-Security: max-age=31536000; includeSubDomains\\nX-Content-Type-Options: nosniff\\nContent-Language: en\\n\")), mdx(\"p\", null, \"Cool, I get redirected to the keycloak login page. Lets use the credentials of the test-user I created earlier.\\nTo use the received access token for further commands, I am storing it inside a shell variable by using the command-line\\nJSON processor \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stedolan.github.io/jq/\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"jq\")), \" for grabbing it from the JSON response.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> ACCESS_TOKEN=`curl -s --location --request POST 'http://keycloak.local/auth/realms/test/protocol/openid-connect/token' \\\\\\n--header 'Content-Type: application/x-www-form-urlencoded' \\\\\\n--data-urlencode 'grant_type=password' \\\\\\n--data-urlencode 'username=test-user-1' \\\\\\n--data-urlencode 'password=1234' \\\\\\n--data-urlencode 'client_id=httpbin' \\\\\\n--data-urlencode 'client_secret=1f134722-0c21-4490-8bf6-faec7f61490b' | jq -r .access_token`\\n\\n> curl http://httpbin.local/bearer -H \\\"Authorization: Bearer ${ACCESS_TOKEN}\\\"\\n\\n{\\n  \\\"authenticated\\\": true,\\n  \\\"token\\\": \\\"eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJkMXZuY3pWU0R0VHdJOExXb3JQOFBfQUx3QkN4N25ZSURadFNYOVNSZUl3In0.eyJleHAiOjE1ODk1NDQwOTcsImlhdCI6MTU4OTU0Mzc5NywianRpIjoiZjEzZmNlMDQtZWI0OS00M2Y3LWJkYjgtMmI1MzdhMGYxYTIyIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrLmxvY2FsL2F1dGgvcmVhbG1zL3Rlc3QiLCJhdWQiOlsiaHR0cGJpbiIsImFjY291bnQiXSwic3ViIjoiMDRiMGY3YmMtMTY0YS00ZDlhLTk5MTgtZjVlNGQzNzdkYmI5IiwidHlwIjoiQmVhcmVyIiwiYXpwIjoiaHR0cGJpbiIsInNlc3Npb25fc3RhdGUiOiJjMDI1NGIwOC00YzIwLTQwMzItYTYwMi1mYzY2ZWVmOGUyNzkiLCJhY3IiOiIxIiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iXX0sInJlc291cmNlX2FjY2VzcyI6eyJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwgaHR0cGJpbi1zY29wZSIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwibmFtZSI6Ik1heCBNdXN0ZXJtYW5uIiwicHJlZmVycmVkX3VzZXJuYW1lIjoidGVzdC11c2VyLTEiLCJnaXZlbl9uYW1lIjoiTWF4IiwiZmFtaWx5X25hbWUiOiJNdXN0ZXJtYW5uIiwiZW1haWwiOiJ0ZXN0LXVzZXItMUBtYWlsLmNvbSJ9.nFI7zz-Y1j1iuWyJ4ytUpAOuqB_Am_mQ12cB1HPvwr2oVOsOw7idKS51xcM1zOvwIV0BxrIQQlrAjjVMVHpxP3qyMBDDvS5_otNNszSZ1dhn5wyabLXqvGFwtRLAavHC0eFdy8dvUXmhznzmrLSnq-1SINt7IZsEB408SVO-V2PT1TmJHumfoTaqUx5xAbkhWvEakwGgt1FuxrgvLPOVLbu0xtdzRkYDLnAEKZrDvpnito4OoD5S-3fV5mJyUJ0U7Fq4ZTeO_4R1OLpubSiam9XiX8zRnM9VxutvNZU8gIIYYqr0Hi5eXA3sG__OueD_zkWdYDn0Q4plzE9K-R3ceg\\\"\\n}\\n\")), mdx(\"p\", null, \"Et Voil\\xE0! After getting an access token for my test-user, I can finally pass through gatekeeper to my httpbin application, showing that I am authenticated.\\nGoal reached! :) For upstream services it might be necessary to get some user information as well. These can be obtained from custom headers forwarded\\nby gatekeeper.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\",\n    \"metastring\": \"noLineNumbers\",\n    \"noLineNumbers\": true\n  }), \"> curl http://httpbin.local/headers -H \\\"Authorization: Bearer ${ACCESS_TOKEN}\\\"\\n{\\n  \\\"headers\\\": {\\n    \\\"Accept\\\": \\\"*/*\\\",\\n    \\\"Accept-Encoding\\\": \\\"gzip\\\",\\n    \\\"Authorization\\\": \\\"Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJkMXZuY3pWU0R0VHdJOExXb3JQOFBfQUx3QkN4N25ZSURadFNYOVNSZUl3In0.eyJleHAiOjE1ODk1NDQ1ODgsImlhdCI6MTU4OTU0NDI4OCwianRpIjoiNGZkZGIyZWItOWQyZC00ZmM0LTk2MGMtZWFiY2EyYzk1YzIyIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrLmxvY2FsL2F1dGgvcmVhbG1zL3Rlc3QiLCJhdWQiOlsiaHR0cGJpbiIsImFjY291bnQiXSwic3ViIjoiMDRiMGY3YmMtMTY0YS00ZDlhLTk5MTgtZjVlNGQzNzdkYmI5IiwidHlwIjoiQmVhcmVyIiwiYXpwIjoiaHR0cGJpbiIsInNlc3Npb25fc3RhdGUiOiIyODNkNmU4ZS1mMTUxLTRiZDUtYTFhYi0xODA1ZWQyN2NmZjQiLCJhY3IiOiIxIiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iXX0sInJlc291cmNlX2FjY2VzcyI6eyJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwgaHR0cGJpbi1zY29wZSIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwibmFtZSI6Ik1heCBNdXN0ZXJtYW5uIiwicHJlZmVycmVkX3VzZXJuYW1lIjoidGVzdC11c2VyLTEiLCJnaXZlbl9uYW1lIjoiTWF4IiwiZmFtaWx5X25hbWUiOiJNdXN0ZXJtYW5uIiwiZW1haWwiOiJ0ZXN0LXVzZXItMUBtYWlsLmNvbSJ9.L73SiC24OsRp9ngOTKw0fYUVL9GCECj0VF7TXLev5p5Cd6jfTcGx0YPMwAujKXPgItnDDc-PqaMinLCsx3VP6Nb7E4-2G5nRNOe56cllFZoB0ojYEFFOvpvhr7TwGUwWO0dxZ_ZWaFcbRPeayRdGjEMHeHhXyaQCHlGpuPNH44YBHhXQsJQ6mkNhHYysHWrHvbjt6W7Fdd8CG_OTjN3FS-4vUMGn_9apQNrejP8PgE-ImxMD2pfizERCMZcpUurq2mEIYvOvmhlriqT4AG3mt6BMH8UQ70ISTqJPFxkZajOY_1zgM15FQNs_SjVMfMKsq3cgq0hY-ho7ztnyKzgz3g\\\",\\n    \\\"Host\\\": \\\"127.0.0.1:80\\\",\\n    \\\"User-Agent\\\": \\\"curl/7.70.0\\\",\\n    \\\"X-Auth-Audience\\\": \\\"httpbin,account\\\",\\n    \\\"X-Auth-Email\\\": \\\"test-user-1@mail.com\\\",\\n    \\\"X-Auth-Expiresin\\\": \\\"2020-05-15 12:09:48 +0000 UTC\\\",\\n    \\\"X-Auth-Groups\\\": \\\"\\\",\\n    \\\"X-Auth-Roles\\\": \\\"offline_access,uma_authorization,account:manage-account,account:manage-account-links,account:view-profile\\\",\\n    \\\"X-Auth-Subject\\\": \\\"04b0f7bc-164a-4d9a-9918-f5e4d377dbb9\\\",\\n    \\\"X-Auth-Token\\\": \\\"eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJkMXZuY3pWU0R0VHdJOExXb3JQOFBfQUx3QkN4N25ZSURadFNYOVNSZUl3In0.eyJleHAiOjE1ODk1NDQ1ODgsImlhdCI6MTU4OTU0NDI4OCwianRpIjoiNGZkZGIyZWItOWQyZC00ZmM0LTk2MGMtZWFiY2EyYzk1YzIyIiwiaXNzIjoiaHR0cDovL2tleWNsb2FrLmxvY2FsL2F1dGgvcmVhbG1zL3Rlc3QiLCJhdWQiOlsiaHR0cGJpbiIsImFjY291bnQiXSwic3ViIjoiMDRiMGY3YmMtMTY0YS00ZDlhLTk5MTgtZjVlNGQzNzdkYmI5IiwidHlwIjoiQmVhcmVyIiwiYXpwIjoiaHR0cGJpbiIsInNlc3Npb25fc3RhdGUiOiIyODNkNmU4ZS1mMTUxLTRiZDUtYTFhYi0xODA1ZWQyN2NmZjQiLCJhY3IiOiIxIiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iXX0sInJlc291cmNlX2FjY2VzcyI6eyJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwgaHR0cGJpbi1zY29wZSIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwibmFtZSI6Ik1heCBNdXN0ZXJtYW5uIiwicHJlZmVycmVkX3VzZXJuYW1lIjoidGVzdC11c2VyLTEiLCJnaXZlbl9uYW1lIjoiTWF4IiwiZmFtaWx5X25hbWUiOiJNdXN0ZXJtYW5uIiwiZW1haWwiOiJ0ZXN0LXVzZXItMUBtYWlsLmNvbSJ9.L73SiC24OsRp9ngOTKw0fYUVL9GCECj0VF7TXLev5p5Cd6jfTcGx0YPMwAujKXPgItnDDc-PqaMinLCsx3VP6Nb7E4-2G5nRNOe56cllFZoB0ojYEFFOvpvhr7TwGUwWO0dxZ_ZWaFcbRPeayRdGjEMHeHhXyaQCHlGpuPNH44YBHhXQsJQ6mkNhHYysHWrHvbjt6W7Fdd8CG_OTjN3FS-4vUMGn_9apQNrejP8PgE-ImxMD2pfizERCMZcpUurq2mEIYvOvmhlriqT4AG3mt6BMH8UQ70ISTqJPFxkZajOY_1zgM15FQNs_SjVMfMKsq3cgq0hY-ho7ztnyKzgz3g\\\",\\n    \\\"X-Auth-Userid\\\": \\\"test-user-1\\\",\\n    \\\"X-Auth-Username\\\": \\\"test-user-1\\\",\\n    \\\"X-Forwarded-Host\\\": \\\"httpbin.local\\\",\\n    \\\"X-Scheme\\\": \\\"http\\\"\\n  }\\n}\\n\")), mdx(\"p\", null, \"For having a better and more insightful reading experience I used curl here. Of course it is easier to verify the protection by navigate to\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://httpbin.local\"), \" in browser and go through the flow there.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"I think keycloak is a wonderful piece of software for handling user identity. It might be not the easiest to setup with Kubernetes yet,\\nbut I am confident that especially the keycloak-operator will improve quick and constantly. Using gatekeeper deployed as sidecar to the application\\nyou want to protect by providing a little configuration seems to me like a very scalable and consistent solution. At the time of\\nmicroservices you want to focus as much as possible on business logic. This solution could save you from implementing same authentication\\nlayer over and over again. Additionally it can be applied to protect third-party applications, that do not support any auth flows by themselves,\\nlike dashboards etc.\"), mdx(\"p\", null, \"Happy authenticating and authorizing!\"), mdx(\"h4\", null, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.keycloak.org/getting-started/getting-started-kube\"\n  }), \"https://www.keycloak.org/getting-started/getting-started-kube\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/keycloak/keycloak-operator\"\n  }), \"https://github.com/keycloak/keycloak-operator\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.keycloak.org/docs/latest/securing_apps/#_keycloak_generic_adapter\"\n  }), \"https://www.keycloak.org/docs/latest/securing_apps/#_keycloak_generic_adapter\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#backend-protocol\"\n  }), \"https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#backend-protocol\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Today there are many ways to secure applications. With the rise of Kubernetes you might search for a self hosted open source\nsolution for…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/securing-kubernetes-apps-with-keycloak-and-gatekeeper/","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}