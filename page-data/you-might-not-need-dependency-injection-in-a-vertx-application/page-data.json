{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/you-might-not-need-dependency-injection-in-a-vertx-application/","result":{"data":{"post":{"__typename":"MdxPost","slug":"/you-might-not-need-dependency-injection-in-a-vertx-application/","title":"You might not need Dependency Injection in a Vertx application","date":"25.02.2018","tags":[{"name":"java","slug":"java"},{"name":"vertx","slug":"vertx"},{"name":"dependency injection","slug":"dependency-injection"}],"description":"How to handle dependency injection in a vertx application? Do I need any library or framework? I went through different approaches using java.","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"You might not need Dependency Injection in a Vertx application\",\n  \"date\": \"2018-02-25T00:00:00.000Z\",\n  \"description\": \"How to handle dependency injection in a vertx application? Do I need any library or framework? I went through different approaches using java.\",\n  \"tags\": [\"java\", \"vertx\", \"dependency injection\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For some time I heard/read a lot about the vertx toolkit and since I'm a real fan of reactive programming and event-driven architectures, but also spending most of my time in the java world, it sounded very promising to me and I decided to give it a try. So I started to create my first vertx application.\"), mdx(\"p\", null, \"As always I thought it can't be that hard. I will just start with a practical example and will learn how the framework/toolkit works automatically, without reading the docs at all. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Really bad idea!\"), \" As vertx is really unopiniated, you can write the code in any style and it works. But you should at least follow some basic rules to profit from vertx. So my advice would be at least read the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://vertx.io/docs/vertx-core/java/\"\n  }), \"core manual\"), \".\"), mdx(\"p\", null, \"At some point (still hadn't read the docs completely) I thought about how to apply Dependency Injection when my application is going to be more complex. I had absolutely no idea, so I started to find an answer by using the search engine with search terms like 'vertx dependency injection' and so on. The results - there were just very few related - I got weren't official ones from the vertx team but some custom written libraries like vertx-guice.\\nThat seems to be a way doing it. Let's try it out!\"), mdx(\"h3\", null, \"The experiment\"), mdx(\"p\", null, \"As an example I'm creating a fictional project with some pseudo CRUD operations around a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" entity.\\nThere is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \" interface offering those methods. The implementation of them can be found at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryFooRepository\"), \" class.\\nIn all 3 different appraoches this is going to be our business logic - we only change the way of interacting with it.\"), mdx(\"h3\", null, \"The traditional way\"), mdx(\"h4\", null, \"Dependency Injection with Guice\"), mdx(\"p\", null, \"Let's start with some code and the example descripted above. For our entity class we're using lombok to keep it clean and expressive.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import lombok.Value;\\n\\n@Value\\npublic class Foo {\\n    public final String id;\\n    public final String bar;\\n}\\n\")), mdx(\"p\", null, \"We want to have reactive implementations, so we are going to use rxjava and our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \" interface is defined like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Maybe;\\nimport io.reactivex.Single;\\n\\npublic interface FooRepository {\\n    Single<Foo> save(Foo foo);\\n    Maybe<Foo> findById(String id);\\n}\\n\")), mdx(\"p\", null, \"The corresponding implementation with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Singleton\"), \" annotation looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Maybe;\\nimport io.reactivex.Single;\\n\\nimport javax.inject.Singleton;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Objects;\\n\\n@Singleton\\nclass InMemoryFooRepository implements FooRepository {\\n\\n    private final Map<String, Foo> store = new HashMap<>();\\n\\n    @Override\\n    public Single<Foo> save(Foo foo) {\\n        store.put(foo.id, foo);\\n        return Single.just(foo);\\n    }\\n\\n    @Override\\n    public Maybe<Foo> findById(String id) {\\n        return Single\\n                .just(store.get(id))\\n                .filter(Objects::nonNull);\\n    }\\n}\\n\")), mdx(\"p\", null, \"With Guice we're creating a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Module\"), \" to define which implementation should be bound to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \" when we're going to inject it anywhere.\\nHere we go:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import com.google.inject.AbstractModule;\\n\\npublic class FooModule extends AbstractModule {\\n\\n    @Override\\n    protected void configure() {\\n        bind(FooRepository.class).to(InMemoryFooRepository.class);\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"All the guice setup is done and we are ready to use it in our main application.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import com.google.inject.Guice;\\nimport io.reactivex.Single;\\nimport io.vertx.core.Context;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.Vertx;\\nimport io.vertx.di.foo.Foo;\\nimport io.vertx.di.foo.FooModule;\\nimport io.vertx.di.foo.FooRepository;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\nimport java.util.UUID;\\n\\npublic class MainVerticle extends AbstractVerticle {\\n\\n    private FooRepository fooRepository;\\n\\n    @Override\\n    public void init(Vertx vertx, Context context) {\\n        super.init(vertx, context);\\n        fooRepository = Guice\\n                .createInjector(new FooModule())\\n                .getInstance(FooRepository.class);\\n    }\\n\\n    @Override\\n    public void start(Future<Void> startFuture) {\\n        fooRepository.save(new Foo(UUID.randomUUID().toString(), \\\"foobar\\\"))\\n                .doOnSuccess(foo -> System.out.println(\\\"Saved: \\\" + foo))\\n                .map(foo -> foo.id)\\n                .flatMapMaybe(fooRepository::findById)\\n                .doOnSuccess(foo -> System.out.println(\\\"Found: \\\" + foo))\\n                .map(storedFoo -> storedFoo.bar)\\n                .filter(bar -> bar.equals(\\\"foobar\\\"))\\n                .switchIfEmpty(Single.error(new IllegalStateException(\\\"Expecting input bar value.\\\")))\\n                .toCompletable()\\n                .doOnComplete(() -> System.out.println(\\\"Saved and found foo[bar=foobar] successfully.\\\"))\\n                .subscribe(startFuture::complete, startFuture::fail);\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"As usual in a vertx application our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MainVerticle\"), \" is extending from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AbstractVerticle\"), \". We are overriding the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method to get a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \" instance here. When starting the verticle we are using this instance to execute some example operations. Basically we're saving one Foo entity and trying to find it by id again.\\nOur last class is a simple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Main\"), \" class launching our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MainVerticle\"), \" out of the IDE.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.vertx.core.Launcher;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Launcher.executeCommand(\\\"run\\\", MainVerticle.class.getName());\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"Okay, let's get the output of our application.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"Saved: Foo(id=7f4314e3-1578-44be-9135-a1e29fb9e453, bar=foobar)\\nFound: Foo(id=7f4314e3-1578-44be-9135-a1e29fb9e453, bar=foobar)\\nSaved and found foo[bar=foobar] successfully.\\n\")), mdx(\"p\", null, \"Our implemenation seems to work and everything is fine. Let's go ahead.\"), mdx(\"h3\", null, \"The vertx way\"), mdx(\"h4\", null, \"Via the Eventbus directly\"), mdx(\"p\", null, \"Whenever you'll read something about vertx you will see something like\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The event bus is the nervous system of Vert.x\")), mdx(\"p\", null, \"You can rely on it and should devinitely use it a much as possible.\\nIt supports message strategies like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pub/sub messaging\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"point-to-point/request-response messaging\")), mdx(\"p\", null, \"In our case we will use the last one.\\nLet's try this out.\\nHere is all the code that wasn't changed except of removing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Singleton\"), \" annotation form the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryFooRepository\"), \" class.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import lombok.Value;\\n\\n@Value\\npublic class Foo {\\n    public final String id;\\n    public final String bar;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Maybe;\\nimport io.reactivex.Single;\\n\\npublic interface FooRepository {\\n    Single<Foo> save(Foo foo);\\n    Maybe<Foo> findById(String id);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Maybe;\\nimport io.reactivex.Single;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Objects;\\n\\nclass InMemoryFooRepository implements FooRepository {\\n\\n    private final Map<String, Foo> store = new HashMap<>();\\n\\n    @Override\\n    public Single<Foo> save(Foo foo) {\\n        store.put(foo.id, foo);\\n        return Single.just(foo);\\n    }\\n\\n    @Override\\n    public Maybe<Foo> findById(String id) {\\n        return Single\\n                .just(store.get(id))\\n                .filter(Objects::nonNull);\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"Of course we are removing the guice \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooModule\"), \" from the previous example and instead adding a further verticle called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooVerticle\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Single;\\nimport io.vertx.core.Context;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.Vertx;\\nimport io.vertx.core.json.JsonObject;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\nimport io.vertx.reactivex.core.eventbus.MessageConsumer;\\n\\npublic class FooVerticle extends AbstractVerticle {\\n\\n    public static final String FOO_SERVICE_ADDRESS = \\\"foo-service\\\";\\n\\n    private FooRepository fooRepository;\\n    private MessageConsumer<JsonObject> consumer;\\n\\n    @Override\\n    public void init(Vertx vertx, Context context) {\\n        super.init(vertx, context);\\n        fooRepository = new InMemoryFooRepository();\\n    }\\n\\n    @Override\\n    public void start(Future<Void> startFuture) {\\n        consumer = vertx.eventBus().consumer(FOO_SERVICE_ADDRESS, message -> {\\n            switch (message.headers().get(\\\"action\\\")) {\\n                case \\\"save\\\":\\n                    fooRepository\\n                            .save(message.body().mapTo(Foo.class))\\n                            .map(JsonObject::mapFrom)\\n                            .subscribe(message::reply, e -> message.fail(500, e.getMessage()));\\n                    break;\\n                case \\\"find\\\":\\n                    fooRepository\\n                            .findById(message.body().getString(\\\"id\\\"))\\n                            .switchIfEmpty(Single.error(new RuntimeException(\\\"Foo not found.\\\")))\\n                            .map(JsonObject::mapFrom)\\n                            .subscribe(message::reply, e -> message.fail(404, e.getMessage()));\\n                    break;\\n                default:\\n                    message.fail(400, \\\"Unknown action.\\\");\\n            }\\n        });\\n\\n        consumer.completionHandler(startFuture);\\n    }\\n\\n    @Override\\n    public void stop(Future<Void> stopFuture) {\\n        consumer.unregister(stopFuture);\\n    }\\n}\\n\")), mdx(\"p\", null, \"So what are we doing here? We're instantiating a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryFooRepository\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method. So far so easy.\\nWhen starting the verticle we register a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonObject\"), \" consumer on the event bus for a certain address.\\nDepending on which action header is received from the incoming message we are invoking the corresponding\\nrepository method and sending the result by replying to the message. That's mainly it, let's start using it.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Single;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.eventbus.DeliveryOptions;\\nimport io.vertx.core.json.JsonObject;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\nimport io.vertx.reactivex.core.eventbus.Message;\\nimport java.util.UUID;\\nimport static io.vertx.di.foo.FooVerticle.FOO_SERVICE_ADDRESS;\\n\\npublic class MainVerticle extends AbstractVerticle {\\n\\n    @Override\\n    public void start(Future<Void> startFuture) {\\n        JsonObject fooMessage = new JsonObject()\\n                .put(\\\"id\\\", UUID.randomUUID().toString())\\n                .put(\\\"bar\\\", \\\"foobar\\\");\\n\\n        vertx.eventBus().<JsonObject>rxSend(FOO_SERVICE_ADDRESS, fooMessage, action(\\\"save\\\"))\\n                .map(Message::body)\\n                .doOnSuccess(foo -> System.out.println(\\\"Saved: \\\" + foo))\\n                .map(foo -> new JsonObject().put(\\\"id\\\", foo.getString(\\\"id\\\")))\\n                .flatMap(idMessage -> vertx.eventBus().<JsonObject>rxSend(FOO_SERVICE_ADDRESS, idMessage, action(\\\"find\\\")))\\n                .map(Message::body)\\n                .doOnSuccess(foo -> System.out.println(\\\"Found: \\\" + foo))\\n                .map(storedFoo -> storedFoo.getString(\\\"bar\\\"))\\n                .filter(bar -> bar.equals(\\\"foobar\\\"))\\n                .switchIfEmpty(Single.error(new IllegalStateException(\\\"Expecting input bar value.\\\")))\\n                .toCompletable()\\n                .doOnComplete(() -> System.out.println(\\\"Saved and found foo[bar=foobar] successfully.\\\"))\\n                .subscribe(startFuture::complete, startFuture::fail);\\n    }\\n\\n    private static DeliveryOptions action(String action) {\\n        return new DeliveryOptions().addHeader(\\\"action\\\", action);\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"It looks really similar to the approach with guice. Instead of using the repository directly we are sending messages over the event bus.\\nTherefore we have to decorate our messages with specific action headers and the payload as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonObject\"), \".\\nWe have a little bit more code but in this version we are completely decoupled from any implementation and any domain objects like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \". That's cool!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.vertx.core.Future;\\nimport io.vertx.core.Launcher;\\nimport io.vertx.di.foo.FooVerticle;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Launcher.executeCommand(\\\"run\\\", LauncherVerticle.class.getName());\\n    }\\n\\n    public static class LauncherVerticle extends AbstractVerticle {\\n\\n        @Override\\n        public void start(Future<Void> startFuture) {\\n            vertx.rxDeployVerticle(FooVerticle.class.getName())\\n                    .toCompletable()\\n                    .andThen(vertx.rxDeployVerticle(MainVerticle.class.getName()))\\n                    .toCompletable()\\n                    .subscribe(startFuture::complete, startFuture::fail);\\n        }\\n\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"In our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Main\"), \" class we're deploying the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooVerticle\"), \" before the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MainVerticle\"), \" to ensure that we're not missing any message.\\nHere is the output.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"Saved: {\\\"id\\\":\\\"ac571123-855b-4b2c-b9e9-059d65c273eb\\\",\\\"bar\\\":\\\"foobar\\\"}\\nFound: {\\\"id\\\":\\\"ac571123-855b-4b2c-b9e9-059d65c273eb\\\",\\\"bar\\\":\\\"foobar\\\"}\\nSaved and found foo[bar=foobar] successfully.\\n\")), mdx(\"p\", null, \"Our application is still working and it works as expected!\"), mdx(\"h4\", null, \"Via vertx service proxy\"), mdx(\"p\", null, \"For the last approach we are trying out the so called service proxies which are offered as a separate module by the vertx toolkit.\\nHow do they work? Basically it's almost the same like those in the previous approach except we have less boilerplate code by using some code generation.\\nOur \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" class is the only untouched piece of code.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import lombok.Value;\\n\\n@Value\\npublic class Foo {\\n    public final String id;\\n    public final String bar;\\n}\\n\")), mdx(\"p\", null, \"Due to some restrictions you have to follow when using service proxies, we have to change our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.vertx.codegen.annotations.ProxyGen;\\nimport io.vertx.codegen.annotations.VertxGen;\\nimport io.vertx.core.AsyncResult;\\nimport io.vertx.core.Handler;\\nimport io.vertx.core.json.JsonObject;\\n\\n@ProxyGen\\n@VertxGen\\npublic interface FooRepository {\\n    void save(JsonObject foo, Handler<AsyncResult<JsonObject>> resultHandler);\\n    void findById(String id, Handler<AsyncResult<JsonObject>> resultHandler);\\n}\\n\")), mdx(\"p\", null, \"You can only use primitive types, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonObject\"), \" and some other limited types as parameter - you can find them \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://vertx.io/docs/vertx-service-proxy/java/#_parameter_types\"\n  }), \"here\"), \" and the last parameter always has to be the result handler also returning one of the limited types.\\nBoth annotations \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@ProxyGen\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@VertxGen\"), \" are used by vertx for code generation.\\nSo we also have to add further dependencies and some build config to our project. To focus on code I won't list it here but you can find it in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/FrederikS/vertx-dependency-injection\"\n  }), \"code repository\"), \".\\nAccording to the changes in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooRepository\"), \" interface we also have to change the implementation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.vertx.core.AsyncResult;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.Handler;\\nimport io.vertx.core.json.JsonObject;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass InMemoryFooRepository implements FooRepository {\\n\\n    private final Map<String, Foo> store = new HashMap<>();\\n\\n    @Override\\n    public void save(JsonObject fooData, Handler<AsyncResult<JsonObject>> resultHandler) {\\n        Foo foo = fooData.mapTo(Foo.class);\\n        store.put(foo.id, foo);\\n        resultHandler.handle(Future.succeededFuture(JsonObject.mapFrom(foo)));\\n    }\\n\\n    @Override\\n    public void findById(String id, Handler<AsyncResult<JsonObject>> resultHandler) {\\n        Future<JsonObject> future = store.containsKey(id)\\n                ? Future.succeededFuture(JsonObject.mapFrom(store.get(id)))\\n                : Future.succeededFuture();\\n        resultHandler.handle(future);\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"The logic remains but we have to use the result handler. To successfully generate the proxy code we have to add one further file - a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package-info.java\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"@ModuleGen(name = \\\"foo\\\", groupPackage = \\\"io.vertx.di.foo\\\")\\npackage io.vertx.di.foo;\\n\\nimport io.vertx.codegen.annotations.ModuleGen;\\n\")), mdx(\"p\", null, \"Enough conventions and limitations let's start using it. But first of all we have to register our service in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooVerticle\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.vertx.core.Context;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.Vertx;\\nimport io.vertx.core.eventbus.MessageConsumer;\\nimport io.vertx.core.json.JsonObject;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\nimport io.vertx.serviceproxy.ServiceBinder;\\n\\npublic class FooVerticle extends AbstractVerticle {\\n\\n    public static final String FOO_SERVICE_ADDRESS = \\\"foo-service\\\";\\n\\n    private FooRepository fooRepository;\\n    private MessageConsumer<JsonObject> binder;\\n\\n    @Override\\n    public void init(Vertx vertx, Context context) {\\n        super.init(vertx, context);\\n        fooRepository = new InMemoryFooRepository();\\n    }\\n\\n    @Override\\n    public void start(Future<Void> startFuture) {\\n        binder = new ServiceBinder(vertx.getDelegate())\\n                .setAddress(FOO_SERVICE_ADDRESS)\\n                .register(FooRepository.class, fooRepository);\\n\\n        binder.completionHandler(startFuture);\\n    }\\n\\n    @Override\\n    public void stop(Future<Void> stopFuture) {\\n        binder.unregister(stopFuture);\\n    }\\n}\\n\")), mdx(\"p\", null, \"That's cool - the registration is much cleaner than in the previous approach.\\nWith the help of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ServiceBinder\"), \" class we register our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemoryFooRepository\"), \" on a certain address we are going to use in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MainVerticle\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.reactivex.Single;\\nimport io.vertx.core.Context;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.Vertx;\\nimport io.vertx.core.json.JsonObject;\\nimport io.vertx.di.foo.FooVerticle;\\nimport io.vertx.di.foo.reactivex.FooRepository;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\nimport io.vertx.serviceproxy.ServiceProxyBuilder;\\nimport java.util.UUID;\\n\\npublic class MainVerticle extends AbstractVerticle {\\n\\n    private FooRepository fooRepository;\\n\\n    @Override\\n    public void init(Vertx vertx, Context context) {\\n        super.init(vertx, context);\\n        fooRepository = new FooRepository(new ServiceProxyBuilder(vertx)\\n                .setAddress(FooVerticle.FOO_SERVICE_ADDRESS)\\n                .build(io.vertx.di.foo.FooRepository.class));\\n    }\\n\\n    @Override\\n    public void start(Future<Void> startFuture) {\\n        JsonObject fooData = new JsonObject()\\n                .put(\\\"id\\\", UUID.randomUUID().toString())\\n                .put(\\\"bar\\\", \\\"foobar\\\");\\n\\n        fooRepository.rxSave(fooData)\\n                .doOnSuccess(foo -> System.out.println(\\\"Saved: \\\" + foo))\\n                .map(foo -> foo.getString(\\\"id\\\"))\\n                .flatMap(fooRepository::rxFindById)\\n                .doOnSuccess(foo -> System.out.println(\\\"Found: \\\" + foo))\\n                .map(storedFoo -> storedFoo.getString(\\\"bar\\\"))\\n                .filter(bar -> bar.equals(\\\"foobar\\\"))\\n                .switchIfEmpty(Single.error(new IllegalStateException(\\\"Expecting input bar value.\\\")))\\n                .toCompletable()\\n                .doOnComplete(() -> System.out.println(\\\"Saved and found foo[bar=foobar] successfully.\\\"))\\n                .subscribe(startFuture::complete, startFuture::fail);\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"Via vertx code generation also reactive implementations can be generated. That's why we see the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rxSave\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rxFindById\"), \" method calls here.\\nAt the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method we are building these reactive service proxy clients via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ServiceProxyBuilder\"), \" class.\\nAll direct interactions with the event bus are isolated in the generated proxy classes.\\nWhen taking a look into these we notice that the implementation is pretty similar to ours from the previous approach.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"  public void handle(Message<JsonObject> msg) {\\n    try {\\n      JsonObject json = msg.body();\\n      String action = msg.headers().get(\\\"action\\\");\\n      if (action == null) {\\n        throw new IllegalStateException(\\\"action not specified\\\");\\n      }\\n      accessed();\\n      switch (action) {\\n        case \\\"save\\\": {\\n          service.save((io.vertx.core.json.JsonObject)json.getValue(\\\"foo\\\"), createHandler(msg));\\n          break;\\n        }\\n        case \\\"findById\\\": {\\n          service.findById((java.lang.String)json.getValue(\\\"id\\\"), createHandler(msg));\\n          break;\\n        }\\n        default: {\\n          throw new IllegalStateException(\\\"Invalid action: \\\" + action);\\n        }\\n      }\\n    } catch (Throwable t) {\\n      msg.reply(new ServiceException(500, t.getMessage()));\\n      throw t;\\n    }\\n  }\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"  @Override\\n  public void save(JsonObject foo, Handler<AsyncResult<JsonObject>> resultHandler) {\\n    if (closed) {\\n    resultHandler.handle(Future.failedFuture(new IllegalStateException(\\\"Proxy is closed\\\")));\\n      return;\\n    }\\n    JsonObject _json = new JsonObject();\\n    _json.put(\\\"foo\\\", foo);\\n    DeliveryOptions _deliveryOptions = (_options != null) ? new DeliveryOptions(_options) : new DeliveryOptions();\\n    _deliveryOptions.addHeader(\\\"action\\\", \\\"save\\\");\\n    _vertx.eventBus().<JsonObject>send(_address, _json, _deliveryOptions, res -> {\\n      if (res.failed()) {\\n        resultHandler.handle(Future.failedFuture(res.cause()));\\n      } else {\\n        resultHandler.handle(Future.succeededFuture(res.result().body()));\\n      }\\n    });\\n  }\\n\")), mdx(\"p\", null, \"Here our switch statement on the action header with cases for each service method is.\\nAnd on the client-side we can also see that the params are put into separate properties of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonObject\"), \" and the action header is set, too.\\nOur \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Main\"), \" class is the same as before.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"import io.vertx.di.foo.FooVerticle;\\nimport io.vertx.core.Future;\\nimport io.vertx.core.Launcher;\\nimport io.vertx.reactivex.core.AbstractVerticle;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Launcher.executeCommand(\\\"run\\\", LauncherVerticle.class.getName());\\n    }\\n\\n    public static class LauncherVerticle extends AbstractVerticle {\\n\\n        @Override\\n        public void start(Future<Void> startFuture) {\\n            vertx.rxDeployVerticle(FooVerticle.class.getName())\\n                    .toCompletable()\\n                    .andThen(vertx.rxDeployVerticle(MainVerticle.class.getName()))\\n                    .toCompletable()\\n                    .subscribe(startFuture::complete, startFuture::fail);\\n        }\\n\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"Is the application still working? Here is the output.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"Saved: {\\\"id\\\":\\\"2e702451-4ebe-4ebe-aecc-5d26be9fc5ec\\\",\\\"bar\\\":\\\"foobar\\\"}\\nFound: {\\\"id\\\":\\\"2e702451-4ebe-4ebe-aecc-5d26be9fc5ec\\\",\\\"bar\\\":\\\"foobar\\\"}\\nSaved and found foo[bar=foobar] successfully.\\n\")), mdx(\"p\", null, \"Yes it is.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"Let's recap - With the event bus we get a mighty instrument from the vertx toolkit, which we should use.\\nIt's almost as easy as guice to setup, the code isn't looking more complicated and is even stronger decoupled.\\nSo my advice would be: In most cases you don't need a DI library within a vertx application and whenever you would create\\na guice module start creating a new verticle exposing a service on the event bus.\\nYou have to follow some restrictions like using limited types, but it isn't really a disadvantage since it also helps to stay decoupled and if you really need it, there is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@DataObject\"), \" annotation to rescue.\\nThe only limitation I found so far is that you can't stream results over the event bus but I could imagine that this will be added at some point.\\nThat's it - hope it helps! :)\"), mdx(\"h4\", null, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://vertx.io/docs/vertx-core/java/\"\n  }), \"http://vertx.io/docs/vertx-core/java/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://vertx.io/docs/vertx-service-proxy/java/\"\n  }), \"http://vertx.io/docs/vertx-service-proxy/java/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/FrederikS/vertx-dependency-injection\"\n  }), \"https://github.com/FrederikS/vertx-dependency-injection\"), \" (Code Repository)\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"For some time I heard/read a lot about the vertx toolkit and since I'm a real fan of reactive programming and event-driven architecturesâ€¦","timeToRead":5,"banner":null}},"pageContext":{"slug":"/you-might-not-need-dependency-injection-in-a-vertx-application/","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}